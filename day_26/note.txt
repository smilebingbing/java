2. HttpServlet:

1). 是一个Servlet, 继承自GenericServlet.针对于HTTP协议所定制

2). 在service() 方法中直接把ServletRequest 和ServletResponse 转为HttpServletRequest 和HttpServletResponse
并调用了重载的service(HttpServletRequest ,HttpServletResponse)

在service(HttpServletRequest ,HttpServletResponse)获取了请求方式:request.getMethod().
根据请求方式又创建了doXxx()方法(xxx为具体的请求方式，比如doGet,doPost)

	@Override
	public void service(ServletRequest arg0, ServletResponse arg1) throws ServletException, IOException {

			HttpServletRequest request;
			HttpServletResponse response;
			
			try{
					request =(HttpServletRequest) req;
					response =(HttpServletResponse) res;
	          }catch(ClassCastException e){
	               throw new ServletException("non-HTTP request or response");
	               }
	               service(request,response);
	  }

	

	public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
	
		//1. 获取请求方式
		String method = request.getMethod();
		
		//2. 根据请求方式再调用对应的处理方法
		if("GET".equalsIgnoreCase(method)){
			doGet(request,response);
		}else if("POST".equalsIgnoreCase(method)){
			doPost(request,response);
		}
	
	
	}
	public void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException,IOException{
		// TODO Auto-generated method stub
		
	}



	public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException,IOException{
		// TODO Auto-generated method stub
		
	}

3). 实际开发中，直接继承HttpServlet.并根据请求方法覆盖重写doXxx()方法接口

4). 好处 : 直接由针对性的覆盖doXxx()方法，直接使用HttpServletRequest 和HttpServletResponse, 不再需要强转




1. GenericServlet:

1). 是一个Servlet. 是Servlet接口和ServletConfig接口的实现类
但是一个抽象类，其中的service 方法为抽象方法

2). 如果新建的Servlet程序直接继承GenericServlet 会使开发更简单

3). 具体实现：

---1---在GenericServlet 中声明了一个ServletConfig 类型的成员变量，在init(ServletConfig)方法中对其进行了初始化

---2---利用servletConfig 成员变量的方法实现了ServletConfig 接口的方法

---3---还定义了一个init()方法，在init(ServletConfig) 方法中对其进行调用，子类可以直接覆盖init() 在其中实现对Servlet的初始化

---4---不建议直接覆盖init(ServletConfig),因为如果忘记编写super.init(ServletConfig),而还是用了ServletConfig接口的方法，
则会出现空指针异常。

---5---新建的init(){}方法并非 Servlet 的生命周期方法，而init(ServletConfig) 是生命周期相关的方法
public abstract class GenericServlet implements Servlet, ServletConfig {

	/** 以下方法为Servlet 接口的方法**/
	@Override
	public void destroy() {}

	@Override
	public ServletConfig getServletConfig() {

		return servletConfig;
	}

	@Override
	public String getServletInfo() {
		// TODO Auto-generated method stub
		return null;
	}

	private ServletConfig servletConfig;
	
	@Override
	public void init(ServletConfig arg0) throws ServletException {
		// TODO Auto-generated method stub

		this.servletConfig=arg0;
	}

	@Override
	public abstract void service(ServletRequest arg0, ServletResponse arg1) throws ServletException, IOException ;

	/**
	 * 以下方法为ServletConfig接口的方法
	 */
	
	@Override
	public String getInitParameter(String arg0) {
		// TODO Auto-generated method stub
		return servletConfig.getInitParameter(arg0);
	}

	@Override
	public Enumeration<String> getInitParameterNames() {
		// TODO Auto-generated method stub
		return servletConfig.getInitParameterNames();
	}

	@Override
	public ServletContext getServletContext() {
		// TODO Auto-generated method stub
		return servletConfig.getServletContext();
	}

	@Override
	public String getServletName() {
		// TODO Auto-generated method stub
		return servletConfig.getServletName();
	}
	
	public void init(ServletConfig config) throws ServletException{
	this.config=config;
	this.init();
